[@by Ruth92](http://www.cnblogs.com/Ruth92/)（转载请注明出处）

## 第3章：字面量和构造函数

#### <p style="background:orange;">创建对象的三种方式：</p>

	// 对象字面量
	var car = {goes: "far"};

	// 内置构造函数
	var car = new Object();
	car.goes = "far";

	// 自定义构造函数
	var adam = new Person("Adam");
	adam.say();

**对象字面量的优点：**

- 按需创建对象，在程序生命周期内的任何时候都可以修改；
- 输入更短的字符；
- 强调该对象仅是一个可变哈希映射，而不是从对象中提取的属性和方法；
- 没有作用域解析

**构造函数的特征（使用缺点）：**

- 依赖传递的参数的值，该构造函数可能会委派另一个内置构造函数来创建对象，并且返回了一个并非期望的不同对象
- 当传递给构造函数的值是动态的，并且直到运行时才能确定其类型
	
		// 一个空对象
		var o = new Object();
		console.log(o.constructor === Object);  // true
		
		// 一个数值对象
		var o = new Object(1);
		console.log(o.constructor === Number);  // true
		console.log(o.toFixed(2));  // '1.00'	

JavaScript 中没有类的概念，但是它却支持极大的灵活性，因为不必预先知道对象的一切细节，也不需要类“蓝图”。

	// 构造函数的定义
	var Person = function(name) {
	  this.name = name;
	  this.say = function() {
	    return "I am " + this.name;
	  };
	};

当 new 操作符调用构造函数时，相当于在后台发生了如下事情：

	var Person = function(name) {
	
	  // 使用对象字面量模式创建一个对象
	  // var this = {};
	
	  // 向 this 添加属性和方法
	  this.name = name;
	  this.say = function() {
	    return "I am" + this.name;
	  };
	
	  // return this;
	}

**构造函数的返回值：**

- 当用 `new` 操作符创建对象时，构造函数总是返回一个对象；
- 默认返回 `this` 所引用的对象，也可以返回任意其他对象；
- 如果试图返回并非对象的值，函数会忽略该值，并返回 `this` 所引用的对象。

> 如果在调用构造函数时，忘记使用 `new` 操作符，会导致构造函数中的 `this` 指向全局对象。

**自调用构造函数**——解决忘记使用 `new` 的问题，同时还能使实例继承原型

	// 自调用构造函数
	function Waffle() {
	
	  if ( !(this instanceof Waffle) ) {
	    return new Waffle;
	  }
	
	  this.tastes = "yummy";
	
	}
	
	Waffle.prototype.wantAnother = true;
	
	// 测试调用
	var first = new Waffle(),
	    second = Waffle();
	
	console.log(first.tastes);  // "yummy";
	console.log(second.tastes);  // "yummy";
	console.log(first.wantAnother);   // "true";
	console.log(second.wantAnother);   // "true";

另一种检测实例对象的方法：

	if ( !(this instanceof arguments.callee) ) {
	return new arguments.callee();
	} 


##### 检测是否为数组：

`Array.isArray()`

	function polyfillArray(arr) {
	
	  if (typeof Array.isArray === 'undefined') {
	    Array.isArray = function(arg) {
	      return Object.prototype.toString.call(arg) === "[object Array]";
	    };
	  }
	
	  return Array.isArray(arr);
	}
	
	polyfillArray([]);  // 'true'
	
	polyfillArray({
	  length: 1,
	  "0": 1,
	  slice: function () {}
	}); // false