### <p style="background:orange;">第1章 作用域是什么</p>

*抛出问题*：程序中的变量存储在哪里？程序需要时，如何找到它们？

设计 `作用域` 的*目的*：为了更好地存储和访问变量。

`作用域`：根据名称查找变量的一套规则，用于确定在何处以及如何查找变量（标识符）。

#### 编译原理

JavaScript 是一门编译语言，但它*不是* 提前编译的，编译结果也不能在分布式系统中进行移植。

程序的源代码在执行前的三个步骤，统称为<span style="background:yellow">“编译”</span>：

1. 分词/词法分析：将字符串分解成代码块（词法单元）
2. 解析/语法分析：将词法单元流（数组）转换成抽象语法树（Abstract Syntax Tree, AST）
3. 代码生成：将AST转换成可执行代码

JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化。JavaScript 的编译不是发生在构建之前，而是<span style="background:yellow">发生在代码执行前的几微秒，甚至更短</span>。因此，JavaScript 引擎用尽了各种方法来保证新更能最佳。

#### 理解作用域

- 引擎
	
	从头到尾负责整个JavaScript程序的编译及执行过程；

- 编译器

	负责语法分析及代码生成；

- 作用域

	负责收集并维护所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

> 总结：变量的赋值操作会执行两个动作——>
> 
> 1）编译器会在当前作用域中声明一个变量（如果之前没有声明过）；
> 2）在运行时，引擎会在作用域中查找该变量，如果能够找到就会对它赋值。

###### 引擎的LHS查询和RHS查询

- LHS查询：赋值操作的左侧，试图找到变量的容器本身，从而可以对其赋值；

		// 不关心当前的值是什么，只是想要为 =2 这个赋值操作找到一个目标
		a = 2;
		
> 不成功的 LHS引用 会导致自动隐式创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常。

- RHS查询：赋值操作的右侧，查找某个变量的值。

		// a 并没有赋予任何值
		// 需要查找并取得 a 的值，这样才能传递给 console.log(...)		
		console.log( a );

> 不成功的 RHS 查询引用会抛出 ReferenceError 异常。

###### 嵌套作用域

LHS 查询和 RHS 查询都会在当前执行作用域中开始，如果没有找到，就会向上级作用域继续查找目标标识符，直至抵达全局作用域，便停止。

### <p style="background:orange;">第2章 词法作用域</p>

作用域的两种工作模型：

- 词法作用域：定义在词法阶段的作用域，即，是由你在写代码时将变量和块作用域写在哪里来决定的。
- 动态作用域。

![嵌套作用域]()

> 作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的。

#### 查找

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

#### 欺骗词法

—— 在运行期修改书写期的词法作用域，会导致性能下降，不要使用。

**(1) eval:** 接受一个字符串作为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。会修改词法作用域。

	function foo(str, a) {
	  eval( str );  // 欺骗！
	  console.log(a, b);
	}
	
	var b = 2;
	
	foo( 'var b = 3;', 1);  // 1,3

> 在严格模式中，无法修改所在的作用域。

**(1) with:** 重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。会重新创建一个全新的词法作用域。

> 在严格模式中，with 被完全禁止。 

### <p style="background:orange;">第3章 函数作用域和块作用域</p>

函数作用域：指属于这个函数的全部变量都可以在整个函数的范围内使用及复用（嵌套作用域也可以）。

- 最小特权原则（最小授权/最小暴露原则）
		
	指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。

隐藏作用域的好处：

- 遵循最小特权原则，避免暴露过多的变量和函数；
- 避免同名标识符之间的冲突。 

规避冲突的方式：1）全局命名空间；2）模块管理。

函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。前者会绑定在所在作用域中，而后者会绑定在函数表达式自身的函数中而不是所在作用域中。 

*行内函数表达式* 可以解决匿名函数表达式的缺点。始终给函数表达式命名是一个最佳实践。

	setTimeout(function timeoutHandler() {
	  //...
	}, 1000);


### <p style="background:orange;">第4章 提升</p>
### <p style="background:orange;">第5章 作用域闭包</p>