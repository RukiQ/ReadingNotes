## 第2章 模块机制

![JavaScript 的变迁]()

JavaScript 先天缺乏的功能：模块。

#### 一、CommonJS 规范：

JavaScript 规范的缺陷：1）没有模块系统；2）标准库较少；3）没有标准接口；4）缺乏包管理系统。

CommonJS 规范的提出，主要是为了弥补当前 JavaScript 没有标准的缺陷，使其具备开发大型应用的基础能力。

![Node与浏览器以及W3C组织、CommonJS组织、ECMAScript之间的关系]()

Node 借鉴 CommonJS 的 Modules 规范实现了一套非常易用的模块系统，NPM 对 Packages 规范的完好支持使得 Node 应用在开发过程中事半功倍。

☛ 【CommonJS 对模块的定义】：

1. 模块引用：

	`require()` 方法：引入一个模块的 API 到当前上下文中。

		var math = require('math');

2. 模块定义：

	`module` 对象：代表模块自身。

	`exports` 对象：`module` 的属性，用于导出当前模块的方法或者变量，且它是唯一导出的出口。
	
	在 Node 中，一个文件就是一个模块，将方法挂载在 `exports` 对象上作为属性即可定义导出的方式：

		// math.js
		exports.add = function() {};

3. 模块标识：传递给 `require()` 方法的参数

	![模块定义]()

♫ 【优点】：CommonJS 构建的这套模块导出和引入机制使得用户完全不必考虑变量污染，命名空间等方案与之相比相形见绌。

#### 二、Node 的模块实现

在 Node 中引入模块，需要经历：（1）路径分析；（2）文件定位；（3）编译执行。

Node 中的模块分为两类：

（1）核心模块：在 Node 源代码编译过程中，编译进了二进制执行文件，所以在引入时，可以省略文件定位和编译执行，且在路径分析中优先判断，加载速度最快。

（2）文件模块：在运行时动态加载，需要完整的3步过程，速度较慢。

☛ 【详细的模块加载过程】：

1. 优先从缓存加载（第一优先级）

	♫ 提高性能的方式比较：

	- 前端浏览器：缓存静态脚本文件，仅缓存文件。
	- Node：对引入过的模块进行缓存，缓存的是编译和执行之后的对象。

	> 无论是核心模块还是文件模块，`require()` 方法对相同模块的二次加载都一律采用缓存优先的方式。
	> 
	> 核心模块的缓存检查先于文件模块。

2. 路径分析与文件定位

	1) 模块标识符分析
	
	- 核心模块：如 http、fs、path 等。（最快）
	- 路径形式的文件模块：`.` 或 `..` 开始的相对路径文件模块 和 以 `/` 开始的绝对路径文件模块。
	- 自定义模块：特殊的文件模块，可能是一个文件或者包的形式。（最慢）

	模块路径：Node 在定位文件模块的具体文件时指定的查找策略，具体表现为一个路径组成的数组。

3. 模块编译


#### 三、核心模块

#### 四、c/C++ 扩展模块

#### 五、模块调用栈

#### 六、包与 NPM

#### 七、前后端共用模块

