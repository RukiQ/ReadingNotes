## 实现继承的6种方式（完整版）

许多OO语言都支持两种继承方式：

（1）接口继承：只继承方法签名；

（2）实现继承：继承实际的方法。

ECMAScript 由于函数没有签名，无法实现接口继承，因此只支持实现继承，而且主要是依靠原型链来实现的。

### <p style="background: orange">1. 原型链 —— 实现继承的主要方法，但是由于其问题，实践中很少会单独使用</span>

<span style="color:red">基本思想：</span>利用原型让一个引用类型继承另一个引用类型的属性和方法。

<span style="background:yellow">原型链的实现</span>：让原型对象等于另一个类型的实例，层层递进，构成实例与原型的链条。

##### 实现原型链的基本模式：
> <span style="color:red">实现本质</span>：重写原型对象，代之以一个新类型的实例

	// 原型链继承--基本模式
	function SuperType() {
		this.property = true;
	}
	
	SuperType.prototype.getSuperValue = function() {
		return this.property;
	};
	
	function SubType() {
		this.subproperty = false;
	}
	
	/*
	 * 继承实现方式：通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype
	 * 实现本质：重写原型对象，代之以一个新类型的实例
	 */
	SubType.prototype = new SuperType();
	
	// 添加新方法
	SubType.prototype.getSubValue = function() {
		return this.subproperty;
	}
	
	// 创建实例并操作
	var instance = new SubType();
	
	alert(instance.getSuperValue());	// true
	
	// instance.constructor 现在指向的是 SuperType
	alert(instance.constructor);	// SuperType
	
	/*
	 * 所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype
	 */
	// SuperType 继承了 Object，能够调用保存在 Object.prototype 中的那个方法
	alert(intance.toString());	"[object Object]"
	
	/*
	 * 确定原型和实例的关系
	 */
	// 方法1：使用 instanceof 操作符
	alert(instance instanceof Object);	// true
	alert(instance instanceof SuperType);	// true
	alert(instance instanceof SubType);	// true
	
	// 方法2：使用 isPrototypeOf() 方法
	alert(Object.prototype.isPrototypeOf(instance));	// true
	alert(SuperType.prototype.isPrototypeOf(instance));	// true
	alert(SubType.prototype.isPrototypeOf(instance));	// true

![原型链继承](https://github.com/RukiQ/blog-learning-patch/blob/master/JS-PJfWD/JS%E5%AF%B9%E8%B1%A1&%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.png?raw=true)

> <span style="color:red">注意点</span>：
> 
> （1）图中，`getSuperValue()` 方法仍然还在 `SuperType.prototype` 中，但 `property` 则位于 `SubType.ptototype` 中。这是因为 `property` 是一个实例属性，而 `getSuperValue()` 则是一个原型方法。
>
> （2）`instance.constructor` 现在指向的是 `SuperType`，这是因为原来 `SubType.prototype` 中的 `constructor` 指向了 `SuperType` 的原型，而这个原型对象的 `contructor` 属性指向的是 `SuperType`。 

通过实现原型链，本质上扩展了原型搜索机制。

- 例：调用 instance.getSuperValue() 会经历三个搜索步骤：1）搜索实例；2）搜索 SubType.prototype；3）搜索 SuperType.prototype，最后一步才会找到该方法。

##### <span style="background:yellow">别忘记默认的原型</span>

- 所有引用类型默认都继承了 `Object`

- 所有函数的默认原型都是 `Object` 的实例，因此默认原型都会包含一个内部指针，指向 `Object.prototype`。

- 因此，所有自定义类型都会继承 `toString()`、`valueOf()` 等默认方法。

![完整的原型链](https://github.com/RukiQ/blog-learning-patch/blob/master/JS-PJfWD/JS%E5%AF%B9%E8%B1%A1&%E5%8E%9F%E5%9E%8B/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%8E%9F%E5%9E%8B%E9%93%BE.png?raw=true)

##### <span style="background:yellow">确定实例与原型的关系</span>：1）`instanceof` 操作符；2）`isPrototypeOf()` 方法

##### <span style="background:yellow">谨慎地定义方法</span>：给原型添加方法的代码一定要放在替换原型的语句之后

	/*
	 * 谨慎地定义方法：给原型添加方法的代码一定要放在替换原型的语句之后
	 */
	function SuperType() {
		this.property = true;
	}
	
	SuperType.prototype.getSuperValue = function() {
		return this.property;
	};
	
	function SubType() {
		this.subproperty = false;
	}
	
	// 继承了 SuperType
	SubType.prototype = new SuperType();
	
	// 添加新方法
	SubType.prototype.getSubValue = function() {
		return this.subproperty;
	}
	
	// 重写超类型中的方法，会屏蔽原来的那个方法
	SubType.prototype.getSuperValue = function() {
		return false;
	}
	
	var instance = new SubType;
	alert(instance.getSuperValue());	// false

<span style="color:red">注意：</span>在通过原型链实现继承时，<span style="background:yellow">-不能使用对象字面量创建原型方法</span>。因为这样会重写原型链。

	/*
	 * 不能使用对象字面量创建原型方法，因为这样会重写原型链
	 */
	function SuperType() {
		this.property = true;
	}
	
	SuperType.prototype.getSuperValue = function() {
		return this.property;
	};
	
	function SubType() {
		this.subproperty = false;
	}
	
	// 继承了 SuperType
	SubType.prototype = new SuperType();
	
	/*
	 * 使用字面量添加新方法，会导致上一行代码无效
	 * 现在 SubType.prototype 是一个 Object 的实例
	 */
	SubType.prototype = {
		getSubValue : function() {
			return this.subproperty;
		},
	
		someOtherMethod : function() {
			return false;
		}
	}
	
	var instance = new SubType;
	console.log(SubType.prototype);	// Object {}
	alert(instance.getSuperValue());	// error!

##### <span style="background:yellow">原型链的问题</span>：

<span style="color:red">主要问题：</span>来自包含引用类型值的原型。

—— 在通过实例来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。

<span style="color:red">问题2：</span>在创建子类型的实例时，不能向超类型的构造函数中传递参数（在不影响所有对象实例的情况下）。

	/*
	 * 原型链的问题
	 */
	function SuperType() {
		this.colors = ["red", "blue", "green"];
	}
	
	function SubType() {
	}
	
	// 继承了 SuperType
	SubType.prototype = new SuperType();
	
	var instance1 = new SubType();
	instance1.colors.push("black");
	console.log(instance1.colors);	// ["red", "blue", "green", "black"]
	
	var instance2 = new SubType();
	console.log(instance2.colors);	// ["red", "blue", "green", "black"]

### <p style="background: orange">2. 借用构造函数（伪造对象或经典继承）—— 实践中很少单独使用</p>

<span style="color:red">优点</span>：

- 解决原型中包含引用类型值所带来的问题。

- 可以在子类型构造函数中向超类型构造函数传递参数。

<span style="color:red">基本思想：</span>在子类型构造函数的内部调用超类型构造函数。

	// 借用构造函数实现继承
	function SuperType() {
		this.colors = ["red", "blue", "green"];
	}
	
	function SubType() {
		// 继承了 SuperType
		SuperType.call(this);	// 在新创建的对象上执行构造函数
	}
	
	var instance1 = new SubType();

	instance1.colors.push("black");
	console.log(instance1.colors);	// ["red", "blue", "green", "black"]
	
	var instance2 = new SubType();
	console.log(instance2.colors);	// [red", "blue", "green"]

> 通过 `call()` 方法或 `apply()` 方法，实际上是在（未来将要）新创建的 SubType 的实例的环境下调用了 SuperType 构造函数。
> 
> 这样一来，会在新 SubType 对象上执行 SuperType() 函数中定义的所有对象初始化代码
>
> 结果，SubType 的每个实例都会有自己的 colors 属性的副本了

##### <span style="background:yellow">传递参数</span>：
	
	// 传递参数
	function SuperType(name) {
		this.name = name;
	}
	
	function SubType() {
		// 继承了 SuperType，同时还传递了参数
		SuperType.call(this, "Nicholas");
	
		// 实例属性
		this.age = 29;
	}
	
	var instance = new SubType();
	
	alert(instance.name);	// "Nicholas"
	alert(instance.age);	// 29

	// 实例的 constructor 属性指向 SubType，因此无法使用原型中定义的方法
	console.log(instance.constructor);	// function SubType() {}

##### <span style="background:yellow">借用构造函数的问题：</p>

1）无法避免构造函数模式存在的问题——方法都在构造函数中定义，无法实现函数复用。

2）在超类型的原型中定义的方法，对子类型而言是不可见的，结果所有类型都只能使用构造函数模式。

### <p style="background: orange">3. 组合继承（伪经典继承）—— 最常用的继承模式</p>

<span style="color:red">优点</span>：将原型链和借用构造函数的技术组合到一块，发挥二者之长。

<span style="color:red">基本思想：</span>使用原型链实现对原型属性和方法的继承，通过借用构造函数实现对实例属性的继承。

	// 组合继承
	function SuperType(name) {
		this.name = name;
		this.colors = ["red", "blue", "green"];
	}
	
	SuperType.prototype.sayName = function() {
		alert(this.name);
	}
	
	function SubType(name, age) {
	
		// 继承属性
		SuperType.call(this, name);
	
		this.age = age;
	}
	
	// 继承方法
	SubType.prototype = new SuperType();
	SubType.prototype.constructor = SubType;
	SubType.prototype.sayAge = function() {
		alert(this.age);
	}
	
	var instance1 = new SubType("Nicholas", 29);
	
	instance1.colors.push("black");
	console.log(instance1.colors);	// ["red", "blue", "green", "black"]
	instance1.sayName();	// "Nicholas"
	instance1.sayAge();	// 29
	
	var instance2 = new SubType("Greg", 27);
	console.log(instance2.colors);	// [red", "blue", "green"]
	instance2.sayName();	// "Greg"
	instance2.sayAge();	// 27

> `instnceof` 和 `isPrototypeOf()` 方法能够用于识别基于组合继承创建的对象

### <p style="background: orange">4. 原型式继承</p>


### <p style="background: orange">5. 寄生式继承</p>


### <p style="background: orange">6. 寄生组合式继承</p>