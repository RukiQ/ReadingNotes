## 创建对象的方式

### <p style="background: orange">一、理解对象</span>

> ECMA-262定义对象：无序属性的集合，其属性可以包含基本值、对象或者属性。

> 我们可以把 ECMAScript 的对象想象成 `散列表`：无非就是一组 `名值对`，其中<span style="background:yellow">值可以是数据或函数。</span>

##### <span style="color:red">创建自定义对象的2种方式：</span>

- 创建一个Object的实例，然后为其添加属性和方法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——最简单（早期开发人员的选择）

	// 创建一个 Object() 的实例，为其添加属性和方法
	var person = new Object();
	person.name = "Nicholas";
	person.age = 29;
	person.job = "Software Engineer";
	
	person.sayName = function() {
		alert(this.name);
	};

	// 使用
	person.age; // 29

- 对象字面量

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——几年后的首选模式
	
	// 对象字面量
	var person = {
		name: "Nicholas",
		age: 29,
		job: "Software Engineer",
	
		sayName: function() {
			alert(this.name);
		}
	};

	// 使用
	person.sayName(); // Nicholas

> 虽然 Object 构造函数或字面量都可以用来创建对象，但这些方式有个明显的 <span style="color:red">缺点</span>：使用同一个接口创建很多对象，会产生大量的重复代码。

### <p style="background: orange">二、创建对象</span>

#### <p style="background: #cfc9fa">（1）工厂模式</span>

> 这种模式抽象了创建具体对象的过程。
> 
> 考虑到 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装特定借口创建对象的细节。

	// 工厂模式
	function createPerson(name, age, job) {
		var o = new Object();	// 显示创建对象
		o.name = name;
		o.age = age;
		o.job = job;
		o.sayName = function() {
			alert(this.name);
		}
		return o;	// 注意返回值
	}
	
	// 使用
	var person1 = createPerson("Nicholas", 29, "Software Engineer");

- 工厂模式虽然解决了<span style="background:yellow">创建多个相似对象</span>的问题，但却没有解决<span style="background:yellow">对象识别</span>的问题。

### <p style="background: #cfc9fa">（2）构造函数模式</p>

> ECMAScript 中的构造函数可用来创建特定类型的对象。

> 像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。

	// 构造函数模式
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = function() {
			alert(this.name);
		}
	}
	
	// 当作构造函数使用，使用 new 操作符，this 指向新创建的实例对象
	var person1 = new Person("Nicholas", 29, "Software Engineer");
	var person2 = new Person("Greg", 27, "Doctor");
	person1.sayName();	// "Nicholas"
	person2.sayName();	// "Greg"
	
	// 作为普通函数使用，this 指向全局 window 对象
	Person("Greg", 27, "Doctor");
	wondow.sayName();	// "Greg"
	
	// 在另一个对象的作用域中调用，this 指向 o
	var o = new Object();
	Person.call(o, "Kristen", 25, "Nurse");
	o.sayName();

##### <span style="background:yellow">与工厂模式的区别：</span>

- 没有显式地创建对象；
- 直接将属性和方法赋给了 `this` 对象
- 没有 `return` 语句

> 使用 `new` 操作符调用构造函数创建实例实际上会经历以下4个步骤：

> (1) 创建一个新对象；

> (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；

> (3) 执行构造函数中的代码（为这个新对象添加属性）；

> (4) 返回新对象。

*构造函数与其他函数的<span style="color:red">唯一区别</span>：调用方式不同——>使用<span style="color:red"> `new` </span>操作符进行调用。

> 任何函数，只要通过 `new` 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 `new` 操作符来调用，那它跟普通函数也不会有什么两样。

##### <span style="background:yellow">构造函数的问题：</span>

- <span style="color:red">主要问题</span>：每个方法都要在每个实例上重新创建一遍。
> 不要忘了，ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义：

		/* 
		 * 以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的
		 * 因此，不同实例上的同名函数是不想等的
		 */
		function Person(name, age, job) {
			this.name = name;
			this.age = age;
			this.job = job;
			this.sayName = new Function("alert(this.name)");
		}
	
		var person1 = new Person("Nicholas", 29, "Software Engineer");
		var person2 = new Person("Greg", 27, "Doctor");		

		alert(person1.sayName == person2.sayName);	// false，如果person1的name和person2的name相同，则为 true

创建两个完成同样任务的 Function 的实例的确没有必要，而且有 `this` 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。可以把**函数定义转移到构造函数外部**来解决这个问题：

	
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = sayName;	// sayName 包含的是一个指向函数的指针
								// 因此,person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName() 函数
	}

	function sayName() {
		alert(this,name);
	}

- <span style="color:red">新问题</span>：上面的做法，<span style="color:#b01c57">在全局作用域中定义的函数只能被某个对象调用</span>，这让全局作用域有点名不副实。而且，如果对象需要定义很多方法，那么就要定义很多个全局函数，那么我们这个自定义的引用类型就丝毫<span style="color:#b01c57">没有封装性</span>可言了。

### <p style="background: #cfc9fa">（3）原型模式</p>

> 我们创建的每个函数都有一个<span style="color:red"> `prototype` </span>（原型）属性，这个属性是一个指针，指向一个对象。

> 原型对象的 <span style="color:red">*用途* </span>是包含可以由特定类型的所有实例共享的属性和方法。

> <span style="background:yellow">按照字面意思来理解：</span> <span style="color:red"> `prototype` </span> 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的 <span style="color:red">*好处* </span>是可以让所有对象实例共享它所包含的属性和方法。

	// 原型模式--示例1
	function Person() {
	}
	
	Person.prototype.name = "Nicholas";
	Person.prototype.age = 29;
	Person.prototype.job = "Software Engineer";
	Person.prototype.sayName = function() {
		alert(this.name);
	}
	
	// 使用
	var person1 = new Person();
	person1.sayName(); // "Nicholas"
	
	var person2 = new Person();
	person2.sayName(); 	// "Nicholas"
	
	alert(person1.sayName == person2.sayName); // true
	
	// Person 的原型对象的 constructor 属性指向 Person
	alert(Person.ptototype.constructor == Person);	//true
	
	// 原型最初指包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问
	alert(preson1.constructor == Person);	// true
	
	// isPrototypeOf() 方法：确定实例与原型对象之间的关系（实例中存在隐藏的[[__proto__]]属性，指向原型对象）
	alert(Person.prototype.isPrototypeOf(person1));	// true;
	
	// Object.getPrototypeOf() 方法：获取实例的原型对象
	alert(Object.getPrototyepOf(person1) == Person.prototype);	// true
	alert(Object.getPrototypeOf(person1).name);	// "Nicholas"
	
	/* 
	 * 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性	
	 * hasOwnProperty() 方法：判断对象属性是存在于实例还是原型中
	 * in 操作符：在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中
	 */
	person1.name = "Greg";
	alert(person1.name);	// "Greg"——来自实例
	alert(person1.hasOwnProperty("name"));	// true
	alert("name" in person1);	// true
	
	alert(person2.name);	// "Nicholas"——来自原型
	alert(person2.hasOwnProperty("name"));	// false	
	alert("name" in person2);	// true
	
	/*
	 * hasOwnProperty() 方法与 in 操作符结合，可以确定该属性是原型中的属性
	 * 自定义 hasOwnPrototypeProperty() 方法：
	 */
	 function hasOwnPrototypeProperty(object, name) {
	 	return !object.hasOwnProperty(name) && (name in object);
	 }
	
	alert(hasOwnPrototypeProperty(person1, "name"));	// false;
	alert(hasOwnPrototypeProperty(person2, "name"));	// true
	
	
	// Object.getOwnPropertyDescriptor() 方法：取得对象属性的描述符
	alert(Object.getOwnPropertyDescriptor(person1, "name"));	// 取得实例属性描述符
	alert(Object.getOwnPropertyDescriptor(Person.prototype, "name"));	// 取得原型属性描述符
	
	/* 
	 * 添加实例属性只会阻止我们访问原型中的那个属性，但不会修改那个属性
	 * 即使将实例属性设置为 null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接
	 */
	person1.name = null;
	alert(person1.name);	// null
	
	// 使用 delete 操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性
	delete person1.name;
	alert(person1.name);	// "Nicholas"——来自原型


##### 补充说明：

- 创建了自定义的构造函数之后，其原型对象<span style="color:red">默认只会取得 `constructor` 属性</span>；至于其他方法，则都是<span style="color:red">从 `Object` 继承而来</span>的。
- 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（<span style="color:red">`[[Prototype]]`</span>，内部属性），指向构造函数的原型对象。
- *注意：* 这个<span style="color:red"> `[[Prototype]]` </span>的连接存在于 <span style="background:yellow">*实例与构造函数的原型对象* </span>之间，而不是存在于实例与构造函数之间。

![Prototype](https://github.com/RukiQ/blog-learning-patch/blob/master/JS-PJfWD/JS%E5%AF%B9%E8%B1%A1&%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B.png?raw=true)

> 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性：

> 1. 搜索从<span style="color:red">对象实例本身</span>开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值；

> 2. 如果没有找到，则继续<span style="color:red">搜索指针指向的原型对象</span>，在原型对象中查找具有给定名字的属性。如果在原型对象中招到了这个属性，则返回该属性的值。

- Person 的原型对象的 <span style="color:red"> `constructor` </span>属性指向 Person
- 原型最初指包含 <span style="color:red">`constructor`</span> 属性，而该属性也是共享的，因此<span style="background:yellow">可以通过对象实例访问</span>
- <span style="color:red">`isPrototypeOf()` 方法</span>：确定实例与原型对象之间的关系（实例中存在隐藏的<span style="color:red">`[[__proto__]]`</span>属性，指向原型对象）
- <span style="color:red">`Object.getPrototypeOf()` 方法</span>：获取实例的原型对象
- <span style="color:red">`hasOwnProperty()` 方法</span>：判断对象属性是存在于实例还是原型中
- <span style="color:red">`in`</span> 操作符：在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中
- <span style="color:red">`hasOwnProperty()`</span> 方法与 <span style="color:red">`in`</span> 操作符结合，可以确定该属性到底是存在于实例中，还是存在于原型中
- <span style="color:red">`Object.getOwnPropertyDescriptor()` 方法</span>：取得对象属性的描述符
- 使用 <span style="color:red">`delete`</span> 操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性

##### <span style="background:yellow">-- 原型与 in 操作符之 for-in 循环</span>

**两种使用方式：**单独使用（前面例子）和在 <span style="color:red">`for-in`</span> 循环中使用

> 在使用 <span style="color:red">`for-in`</span> 循环时，返回的是能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。

> IE早期版本的实现中存在一个bug，即屏蔽不可枚举属性的实例不会出现在 for-in 循环中。

	// for-in 循环
	var o = {
		toString: function() {	// 该自定义方法屏蔽了原型中（不可枚举）的 toString() 方法
			return "My Object";
		}
	};
	
	for (var prop in o) {
		if (prop == "toString") {
			alert("Found toString");	// IE 中不会显示
		}
	}

- 默认不可枚举的所有属性和方法，包括：<span style="color:#b01c57">`hasOwnProperty()`、`propertyIsEnumerable()`、`toLocaleStrig()`、`toString()`、`valueOf()`</span>，ECMAScript也将 <span style="color:#b01c57">`constructor` 和 `prototype` 属性</span>的 [[Enumerable]] 特性设置为 false，但并不是所有浏览器都照此实现

**原型模式示例2：**
（1）取得对象上所有可枚举的实例属性（`Object.keys()` 方法）
（2）得到所有实例属性、无论它是否可枚举（`Object.getOwnPropertyNames()` 方法）

	// 原型模式--示例2
	function Person() {
	}
	
	Person.prototype.name = "Nicholas";
	Person.prototype.age = 29;
	Person.prototype.job = "Software Engineer";
	Person.prototype.sayName = function() {
		alert(this.name);
	}
	
	/*
	 * Object.keys() 方法：取得对象上所有可枚举的实例属性
	 * 该方法将返回一个字符串数组，数组中字符串出现的顺序也是它们在 for-in 循环中出现的顺序
	 */
	var keys = Object.keys(Person.prototype);
	console.log(keys);	// ["name", "age", "job", "sayName"]
	
	var p1 = new Person();
	p1.name = "Rob";
	p1.age = 31;
	var p1keys = Object.keys(p1);
	console.log(p1keys);	// ["name", "age"]
	
	// Object.getOwnPropertyNames() 方法：得到所有实例属性，无论它是否可枚举
	var keys = Object.getOwnPropertyNames(Person.prototype);
	console.log(keys);	// ["constructor", "name", "age", "job", "sayName"]

> Object.keys() 和 Object.getOwnPropertyNames() 方法都可以用来替代 for-in 循环。

##### <span style="background:yellow">-- 更简单的原型语法</span>——为了减少不必要的输入，也为了从视觉上更好地封装原型的功能。

	// 更简单的原型语法
	function Person() {
	}
	
	Person.prototype = {
		name : "Nicholas",
		age : 29,
		job : "Software Engineer",
		sayName : function() {
			alert(this.name);
		}
	}
	
	var friend = new Person();
	alert(friend instanceof Object);	// true
	alert(friend instanceof Person);	// true
	alert(friend.constructor == Person);	// false
	alert(friend.constructor == Object);	// true

> 每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性

> 这种写法，本质上完全重写了默认的 prototype 对象

> constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数）

<span style="color:#b01c57">可以像下面这样设置：</span>

- <span style="color:red">注意：</span>以这种方式重设 constructor 属性会导致它的 [[Enumerable]] 特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的。

		function Person() {
		}
		
		Person.prototype = {
			constructor : Person,
			name : "Nicholas",
			age : 29,
			job : "Software Engineer",
			sayName : function() {
				alert(this.name);
			}
		}
	
		// 重设构造函数，只适用于 ECMAScript 兼容的浏览器
		Object.defineProperty(Person.prototype, "constructor", {
			enumerable: false,
			value: Person
		})

##### <span style="background:yellow">-- 原型的动态性</span>——可以随时为原型添加属性和方法

> 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。

> <span style="color:red">原因：</span>实例与原型之间存在<span style="color:red">松散连接关系</span>。

> 实例与原型之间的连接只不过是一个指针，而非一个副本。

	var friend = new Person();	// 先创建实例
	
	Person.prototype.sayHi = function() {	// 于实例创建后添加
		alert("hi");
	}
	
	friend.sayHi();	// "hi"，可以访问原型中的方法

- 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。

- 我们知道，调用构造函数时会为实例添加一个指向最初原型 [[Prototype]] 的指针，而把原型修改为另一个对象就等于切断了构造函数与最初原型之间的联系。

- 注意：实例中的指针仅指向原型，而不指向构造函数
	
		function Person() {	
		}
		
		var friend = new Person();
		// 重写原型对象
		Person.prototype = {
			constructor : Person,	// 设置 constructor
			name : "Nicholas",
			age : 29,
			job : "Software Engineer",
			sayName : function() {
				alert(this.name);
			}
		}
		
		friend.sayName(); // error

![]()

### <p style="background: #cfc9fa">（4）组合使用构造函数模式和原型模式</p>

### <p style="background: #cfc9fa">（5）动态原型模式</p>

### <p style="background: #cfc9fa">（6）寄生构造函数模式</p>

### <p style="background: #cfc9fa">（7）稳妥构造函数模式</p>