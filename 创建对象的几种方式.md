## 创建对象的方式

### <p style="background: orange">一、理解对象</span>

> ECMA-262定义对象：无序属性的集合，其属性可以包含基本值、对象或者属性。

> 我们可以把 ECMAScript 的对象想象成 `散列表`：无非就是一组 `名值对`，其中<span style="background:yellow">值可以是数据或函数。</span>

##### <span style="color:red">创建自定义对象的2种方式：</span>

- 创建一个Object的实例，然后为其添加属性和方法

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——最简单（早期开发人员的选择）

	// 创建一个 Object() 的实例，为其添加属性和方法
	var person = new Object();
	person.name = "Nicholas";
	person.age = 29;
	person.job = "Software Engineer";
	
	person.sayName = function() {
		alert(this.name);
	};

	// 使用
	person.age; // 29

- 对象字面量

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;——几年后的首选模式
	
	// 对象字面量
	var person = {
		name: "Nicholas",
		age: 29,
		job: "Software Engineer",
	
		sayName: function() {
			alert(this.name);
		}
	};

	// 使用
	person.sayName(); // Nicholas

> 虽然 Object 构造函数或字面量都可以用来创建对象，但这些方式有个明显的 <span style="color:red">缺点</span>：使用同一个接口创建很多对象，会产生大量的重复代码。

### <p style="background: orange">二、创建对象</span>

#### <p style="background: #cfc9fa">（1）工厂模式</span>

> 这种模式抽象了创建具体对象的过程。
> 
> 考虑到 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装特定借口创建对象的细节。

	// 工厂模式
	function createPerson(name, age, job) {
		var o = new Object();	// 显示创建对象
		o.name = name;
		o.age = age;
		o.job = job;
		o.sayName = function() {
			alert(this.name);
		}
		return o;	// 注意返回值
	}
	
	// 使用
	var person1 = createPerson("Nicholas", 29, "Software Engineer");

- 工厂模式虽然解决了<span style="background:yellow">创建多个相似对象</span>的问题，但却没有解决<span style="background:yellow">对象识别</span>的问题。

### <p style="background: #cfc9fa">（2）构造函数模式</p>

> ECMAScript 中的构造函数可用来创建特定类型的对象。

> 像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。

	// 构造函数模式
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = function() {
			alert(this.name);
		}
	}
	
	// 当作构造函数使用，使用 new 操作符，this 指向新创建的实例对象
	var person1 = new Person("Nicholas", 29, "Software Engineer");
	var person2 = new Person("Greg", 27, "Doctor");
	person1.sayName();	// "Nicholas"
	person2.sayName();	// "Greg"
	
	// 作为普通函数使用，this 指向全局 window 对象
	Person("Greg", 27, "Doctor");
	wondow.sayName();	// "Greg"
	
	// 在另一个对象的作用域中调用，this 指向 o
	var o = new Object();
	Person.call(o, "Kristen", 25, "Nurse");
	o.sayName();

##### <span style="background:yellow">与工厂模式的区别：</span>

- 没有显式地创建对象；
- 直接将属性和方法赋给了 `this` 对象
- 没有 `return` 语句

> 使用 `new` 操作符调用构造函数创建实例实际上会经历以下4个步骤：

> (1) 创建一个新对象；

> (2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；

> (3) 执行构造函数中的代码（为这个新对象添加属性）；

> (4) 返回新对象。

*构造函数与其他函数的<span style="color:red">唯一区别</span>：调用方式不同——>使用<span style="color:red"> `new` </span>操作符进行调用。

> 任何函数，只要通过 `new` 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 `new` 操作符来调用，那它跟普通函数也不会有什么两样。

##### <span style="background:yellow">构造函数的问题：</span>

- <span style="color:red">主要问题</span>：每个方法都要在每个实例上重新创建一遍。
> 不要忘了，ECMAScript中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义：

		// 以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的
		// 因此，不同实例上的同名函数是不想等的
		function Person(name, age, job) {
			this.name = name;
			this.age = age;
			this.job = job;
			this.sayName = new Function("alert(this.name)");
		}
	
		var person1 = new Person("Nicholas", 29, "Software Engineer");
		var person2 = new Person("Greg", 27, "Doctor");		

		alert(person1.sayName == person2.sayName);	// false，如果person1的name和person2的name相同，则为 true

创建两个完成同样任务的 Function 的实例的确没有必要，而且有 `this` 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。可以把**函数定义转移到构造函数外部**来解决这个问题：

	
	function Person(name, age, job) {
		this.name = name;
		this.age = age;
		this.job = job;
		this.sayName = sayName;	// sayName 包含的是一个指向函数的指针
								// 因此,person1 和 person2 对象就共享了在全局作用域中定义的同一个 sayName() 函数
	}

	function sayName() {
		alert(this,name);
	}

- <span style="color:red">新问题</span>：上面的做法，<span style="color:b01c57">在全局作用域中定义的函数只能被某个对象调用</span>，这让全局作用域有点名不副实。而且，如果对象需要定义很多方法，那么就要定义很多个全局函数，那么我们这个自定义的引用类型就丝毫<span style="color:b01c57">没有封装性</span>可言了。

### <p style="background: #cfc9fa">（3）原型模式</p>

> 我们创建的每个函数都有一个<span style="color:red"> `prototype` </span>（原型）属性，这个属性是一个指针，指向一个对象。

> 原型对象的 <span style="color:red">*用途* </span>是包含可以由特定类型的所有实例共享的属性和方法。

> <span style="background:yellow">按照字面意思来理解：</span> <span style="color:red"> `prototype` </span> 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的 <span style="color:red">*好处* </span>是可以让所有对象实例共享它所包含的属性和方法。

	// 原型模式
	function Person() {
	}
	
	Person.prototype.name = "Nicholas";
	Person.prototype.age = 29;
	Person.prototype.job = "Software Engineer";
	Person.prototype.sayName = function() {
		alert(this.name);
	}
	
	// 使用
	var person1 = new Person();
	person1.sayName(); // "Nicholas"
	
	var person2 = new Person();
	person2.sayName(); 	// "Nicholas"
	
	alert(person1.sayName == person2.sayName); // true

	// Person 的原型对象的 constructor 属性指向 Person
	alert(Person.ptototype.constructor == Person);	//true

	// 原型最初指包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问
	alert(preson1.constructor == Person);	// true

	// isPrototypeOf() 方法确定实例与原型对象之间的关系（实例中存在隐藏的[[__proto__]]属性，指向原型对象）
	alert(Person.prototype.isPrototypeOf(person1));	// true;

	// Object.getPrototypeOf() 方法获取实例的原型对象
	alert(Object.getPrototyepOf(person1) == Person.prototype);	// true
	alert(Object.getPrototypeOf(person1).name);	// "Nicholas"

	/* 判断对象属性是来自实例还是原型
	 * 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性
	 * /	
	person1.name = "Greg";
	alert(person1.name);	// "Greg"——来自实例
	alert(person2.name);	// "Nicholas"——来自原型

	/* 添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性
	 * 即使将实例属性设置为 null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接
	 */
	person1.name = null;
	alert(person1.name);	// null

	// 使用 delete 操作符可以完全删除实例属性，从而让我们能够重新访问原型中的属性
	delete person1.name;
	alert(person1.name);	// "Nicholas"——来自原型

##### 补充说明：

- 创建了自定义的构造函数之后，其原型对象<span style="color:red">默认只会取得 `constructor` 属性</span>；至于其他方法，则都是<span style="color:red">从 `Object` 继承而来</span>的。
- 当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（<span style="color:red">`[[Prototype]]`</span>，内部属性），指向构造函数的原型对象。
- *注意：* 这个<span style="color:red"> `[[Prototype]]` </span>的连接存在于 <span style="background:yellow">*实例与构造函数的原型对象* </span>之间，而不是存在于实例与构造函数之间。

![Prototype](https://github.com/RukiQ/blog-learning-patch/blob/master/JS-PJfWD/JS%E5%AF%B9%E8%B1%A1&%E5%8E%9F%E5%9E%8B/%E5%8E%9F%E5%9E%8B.png?raw=true)

> 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性：

> 1. 搜索从<span style="color:red">对象实例本身</span>开始，如果在实例中找到了具有给定名字的属性，则返回该属性的值；

> 2. 如果没有找到，则继续<span style="color:red">搜索指针指向的原型对象</span>，在原型对象中查找具有给定名字的属性。如果在原型对象中招到了这个属性，则返回该属性的值。








### <p style="background: #cfc9fa">（4）组合使用构造函数模式和原型模式</p>

### <p style="background: #cfc9fa">（5）动态原型模式</p>

### <p style="background: #cfc9fa">（6）寄生构造函数模式</p>

### <p style="background: #cfc9fa">（7）稳妥构造函数模式</p>